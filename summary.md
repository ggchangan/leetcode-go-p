# 算法总结
## 滑动窗口
窗口起始位置:s
窗口结束位置:e
窗口属性，比如窗口所有元素之和:sum
扩展窗口需要满足的目标:target
初始状态:s,e, sum := 0
获取最小窗口: minL
for e < len(nums) {
    sum += nums[e]
    for s > target { 
        sum -= nums[s]
        minL := min(minL, e-s+1)
        s--//缩小窗口
    }
    e++//扩展窗口
}
例题：209 窗口缩小时，进行逻辑处理
例题: 3 窗口扩展时，进行逻辑处理；要特别注意下标的处理，左侧窗口指向的字符不应该被统计

10月7日
## 二叉树的层次遍历 掌握程度：熟练
### 199 二叉树的右视图，返回二叉树每层节点中最右面的一个节点
1. 二叉树层次遍历模板 https://leetcode.cn/problems/binary-tree-right-side-view/solutions/859784/dai-ma-sui-xiang-lu-wo-yao-da-shi-ge-er-mdkms/?envType=study-plan-v2&envId=top-interview-150
### 637 简单的层次遍历
### 103 层次遍历变种---- Z型遍历
## 二叉搜索树
### 530 二叉排序树中最小差值 
1. 二叉排序树中序遍历，得出排序数组，一次遍历，得出差值最小;
2. 技巧，使用pre=-1记录之前遍历的节点，当pre != -1时，开始差值比较，二叉排序树后面的值总是大于等于前面的值，所以差值是>=0的
### 230 二叉排序树中第k小数
## 图
### 130标记所有中间区域的O
思路：如果一个O没有被包围在中间，那么这个O会间接或者直接与边界的O相连，那么
1. 对边界的O进行深度遍历，标记所有与之相连的O为A，那么这些A就是没有被包围的O
2. 对整个数组进行遍历，将所有的O变成X，将所有的A还原为O
技巧：
1. 找出没有被包围的点
2. 深度优先搜索时，优先排除图外的点，以及不需要遍历的点
### 399除法求值
思路：并查集
### 207, 210
思路： 使用拓扑排序（广度优先搜索）
1. 统计每个节点的入度，并使用队列存储所有入度为0的顶点
2. 构建每个节点能够到达的顶点数组
3. 移除入度为0的顶点，并将此顶点所能到达顶点的入度减1，重复此步骤3，指导所有入度为0的顶点被移除完
4. 如果被移除的顶点个数是所有顶点，则可以完全学完；
或者如果所有课程最终的入度都为0了，也可以
#### TODO 深度优先搜索的方式做此题
## 图广
### 909 蛇梯棋
技巧： 对于无法到达的情况，如何快速结束？？
*** 主要的是使用visited保证已经访问的节点不会被重复访问，加快速度 ***
TODO: 优化
## 回溯
### 77 组合
1. 回溯可以认为是递归，递归调用时，添加回溯的层次，作为递归的参数
2. 回溯一般和减枝联系在一起
### 46 全排列
1. 产生的结果，要深度拷贝过去
```
perm := make([]int, n)
copy(perm, nums)
ans = append(ans, perm)
```
### 39 组合总数
## 数组或者字符串
### 13 罗马数字转整数
技巧：
1. 如果当前字符比后面字符代表的数字小，则减去此字符所代表的值，否则是加上
### 12 整数转罗马数字
技巧：
1. 使用map 
2. strings.Repeat("", cnt)
### 58 最后一个单词的长度
##分治
### 分治的基本思想：分+治+合并
### 108 将有序数组转变为平衡树
1. 找到中间节点，使用此节点分
2. 对左右两部分进行分别处理，处理完的部分为树的左右子树
3. 递归的终止条件，就是分之后数组部分的长度为0或者1
### 148 排序链表
#### 递归方法
1. 对链表进行划分，得到中间节点mid（快慢指针）
2. 对划分后的链表分别排序
3. 对有序数组进行合并
技巧： 分的时候，使用快慢指针，当节点个数是偶数的时候，mid最终指向前一个节点 fast !=nil && fast.Next != nil && fast.Next.Next != nil
如果想要mid指向后一个节点 则使用 fast != nil && fast.Next != nil
#### 自底向上归并排序
TODO
### 23 对k个链表进行排序
思路：使用2路归并算法
### 427 构建4叉树
技巧：每个小方块的确定，使用(r1, r2, c1, c2)
for i:=r1; i<=r2; i++ {
    for j:=c1; j<=c2; j++ {
    }
}
rMid := (r1+r2)/2
cMid := (c1+c2)/2
(r1, rMid, c1, cMid)
(r1, rMid, cMid+1, c2)
(rMid+1, r2, c1, cMid)
(rMid+1, r2, cMid+1, c2)
## 二分查找
适用范围：
1. 目标函数是单调的
2. 存在上下界
3. 可以通过索引访问
### 代码模板
```
func searchInsert(nums []int, target int) int {
	l, r := 0, len(nums)-1
	for l <= r {
		m := (l + r) / 2
		if nums[m] == target {
			return m
		} else if nums[m] < target {
			l = m + 1
		} else {
			r = m - 1
		}
	}

	return l
}
```
最终，左界是待插入位置
### 35 搜索插入位置，简单二分搜索
### 74 搜索二维矩阵
1. 此矩阵的特点是，后一行第一个元素比上一行元素大
2. 方法1，两次2分搜索； 方法2，将矩阵展开，一次2分搜索
### 33 旋转排序数组中的查找
思路：对于这样的数组，中间分开，必定其中一半有序。
如果左边一半有序，并且target在左边范围内，则在左边搜索；否则，在右边搜索
如果右边一半有序，并且target在右边范围内，则在右边搜索；否则，在左边搜索
*** 此题容易出错 ***
### 34 数组中有重复元素，查找重复元素的上下界
我的思路：查找到第一个元素的位置，然后向左右扩展
## 数组
### 274 H指数
思路：基数排序，H指数<=文章数，当引用数>文章数，则记录文章总数
### 238 除自己之外乘积
思路：使用两个数组L、R；L[i]代表i之前元素乘积；R[i]代表i之后元素乘积;ans[i]=L[i]*R[i]
## 链表
### 86 对链表进行分割
思路：构建两个新的链表，然后链接，不在原来的链表上操作
技巧：声明哑节点来应对节点为空的情况